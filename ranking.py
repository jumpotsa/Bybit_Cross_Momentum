import pandas as pd
import numpy as np
import requests
import time
import os
from datetime import datetime
import sys

sys.path.append('.')  # Add current directory to path

# --- CONFIGURATION ---
# Input and output folders
INPUT_DIR = "momentum"
OUTPUT_DIR = "momentum"

# Momentum calculation parameters
DAYS_NEEDED = 370  # Need at least 365 days for 12-1 month calculation
MONTH_1_DAYS = 30  # Days ago for 1-month price
MONTH_12_DAYS = 365  # Days ago for 12-month price

# --- END CONFIGURATION ---

class MomentumAnalyzer:
    """
    Analyzes cryptocurrency momentum using Bybit perpetual futures data.
    """
    
    def __init__(self):
        # Ensure output directory exists
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)
            print(f"Created directory: {OUTPUT_DIR}")
        
        self.base_url = "https://api.bybit.com/v5/market/kline"
        print("Initialized Bybit Perpetual Futures Momentum Analyzer")
    
    def read_coin_list(self):
        """
        Reads coin list from the CSV file generated by list.py.
        """
        input_file = os.path.join(INPUT_DIR, "coin_names_only.csv")
        
        if not os.path.exists(input_file):
            print(f"Error: Input file not found: {input_file}")
            print("Please make sure you have run list.py first.")
            return None
        
        try:
            df = pd.read_csv(input_file)
            print(f"Loaded {len(df)} perpetual contracts from {input_file}")
            
            # Display first few contracts
            if len(df) > 0:
                print("\nFirst 5 contracts:")
                for i in range(min(5, len(df))):
                    print(f"  {i+1}. {df.iloc[i]['symbol']} - {df.iloc[i]['contract']}")
            
            return df
        except Exception as e:
            print(f"Error reading coin list: {e}")
            return None
    
    def fetch_historical_klines(self, symbol, category='linear'):
        """
        Fetches historical kline data from Bybit perpetual futures.
        
        Args:
            symbol: Trading pair symbol (e.g., 'BTCUSDT')
            category: 'linear' for USDT perpetuals or 'inverse' for inverse perpetuals
        
        Returns:
            DataFrame with historical price data or None if failed
        """
        try:
            # Calculate timestamps
            end_time = int(time.time() * 1000)  # Current time in milliseconds
            start_time = end_time - (DAYS_NEEDED * 24 * 60 * 60 * 1000)  # ~370 days ago
            
            params = {
                'category': category,
                'symbol': symbol,
                'interval': 'D',  # Daily candles
                'start': start_time,
                'end': end_time,
                'limit': 1000  # Maximum allowed
            }
            
            all_klines = []
            
            # Bybit returns max 1000 candles, so we may need multiple requests
            while True:
                response = requests.get(self.base_url, params=params)
                response.raise_for_status()
                
                data = response.json()
                
                if data.get('retCode') != 0:
                    print(f"   [X] API Error: {data.get('retMsg')}")
                    return None
                
                klines = data.get('result', {}).get('list', [])
                
                if not klines:
                    break
                
                all_klines.extend(klines)
                
                # Check if we have enough data or reached the end
                if len(klines) < 1000:
                    break
                
                # Update start time for next batch (get older data)
                oldest_timestamp = int(klines[-1][0])
                if oldest_timestamp <= start_time:
                    break
                
                params['end'] = oldest_timestamp
                time.sleep(0.1)  # Rate limiting
            
            if not all_klines or len(all_klines) < MONTH_12_DAYS:
                return None
            
            # Convert to DataFrame
            # Bybit kline format: [timestamp, open, high, low, close, volume, turnover]
            df = pd.DataFrame(all_klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
            
            # Convert types
            df['timestamp'] = pd.to_numeric(df['timestamp'])
            df['open'] = pd.to_numeric(df['open'])
            df['high'] = pd.to_numeric(df['high'])
            df['low'] = pd.to_numeric(df['low'])
            df['close'] = pd.to_numeric(df['close'])
            df['volume'] = pd.to_numeric(df['volume'])
            
            # Sort by timestamp (oldest first)
            df = df.sort_values('timestamp')
            
            # Convert timestamp to datetime
            df['datetime'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('datetime', inplace=True)
            
            return df
            
        except Exception as e:
            print(f"   [X] Error fetching klines for {symbol}: {e}")
            return None
    
    def calculate_momentum(self, df):
        """
        Calculates 12-1 month momentum.
        Formula: (Price 1 month ago / Price 12 months ago) - 1
        """
        try:
            if len(df) < MONTH_12_DAYS:
                return np.nan, np.nan, np.nan, np.nan
            
            # Get prices at the required timeframes
            price_current = df['close'].iloc[-1]
            price_1m_ago = df['close'].iloc[-MONTH_1_DAYS]
            price_12m_ago = df['close'].iloc[-MONTH_12_DAYS]
            
            if price_12m_ago == 0:
                return np.nan, np.nan, np.nan, np.nan
            
            # Calculate 12-1 month momentum
            momentum = (price_1m_ago / price_12m_ago) - 1
            
            return momentum, price_current, price_1m_ago, price_12m_ago
            
        except Exception as e:
            print(f"   [X] Error calculating momentum: {e}")
            return np.nan, np.nan, np.nan, np.nan
    
    def analyze_coins(self, coin_df):
        """
        Analyzes momentum for all perpetual contracts in the dataframe.
        """
        if coin_df is None:
            return None, None
        
        results = []
        total_coins = len(coin_df)
        
        print(f"\nAnalyzing momentum for {total_coins} perpetual contracts...")
        print("="*60)
        
        for index, row in coin_df.iterrows():
            coin_symbol = row['symbol']
            contract_symbol = row['contract']
            
            print(f"[{index+1}/{total_coins}] Processing: {coin_symbol} ({contract_symbol})")
            
            # Determine category (linear or inverse)
            if 'USDT' in contract_symbol or 'USDC' in contract_symbol:
                category = 'linear'
            else:
                category = 'inverse'
            
            # Fetch historical data
            time.sleep(0.12)  # Rate limiting (max 10 requests per second for public endpoints)
            df = self.fetch_historical_klines(contract_symbol, category)
            
            if df is None:
                print(f"   [X] Failed to fetch historical data (need {MONTH_12_DAYS}+ days)")
                continue
            
            # Calculate momentum
            momentum, price_current, price_1m_ago, price_12m_ago = self.calculate_momentum(df)
            
            if pd.isna(momentum):
                print(f"   [X] Insufficient data for momentum calculation")
                continue
            
            # Store result
            results.append({
                'symbol': coin_symbol,
                'contract': contract_symbol,
                'category': category,
                'momentum_12_1': momentum,
                'momentum_percentage': momentum * 100,
                'current_price': price_current,
                'price_1m_ago': price_1m_ago,
                'price_12m_ago': price_12m_ago,
                'data_points': len(df)
            })
            
            print(f"   [OK] Momentum: {momentum:.2%} | Current: ${price_current:.2f}")
        
        if not results:
            print("\nNo contracts with sufficient data found.")
            return None, None, None
        
        # Convert to DataFrame
        results_df = pd.DataFrame(results)
        
        # Sort by momentum
        results_df = results_df.sort_values('momentum_12_1', ascending=False)
        results_df = results_df.reset_index(drop=True)
        
        # Get top 10 and bottom 10
        top_10 = results_df.head(10).copy()
        bottom_10 = results_df.tail(10).copy()
        
        # Add rank column
        top_10['rank'] = range(1, len(top_10) + 1)
        bottom_10['rank'] = range(len(results_df) - len(bottom_10) + 1, len(results_df) + 1)
        
        print(f"\n[OK] Successfully analyzed {len(results)} contracts")
        
        return top_10, bottom_10, results_df
    
    def save_results(self, top_10, bottom_10, all_results):
        """
        Saves the momentum results to CSV files.
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Save top 10
        top_file = os.path.join(OUTPUT_DIR, "top_10_momentum_perpetual.csv")
        top_10.to_csv(top_file, index=False)
        print(f"\n[OK] Top 10 momentum saved to: {top_file}")
        
        # Save bottom 10
        bottom_file = os.path.join(OUTPUT_DIR, "bottom_10_momentum_perpetual.csv")
        bottom_10.to_csv(bottom_file, index=False)
        print(f"[OK] Bottom 10 momentum saved to: {bottom_file}")
        
        # Save all results
        all_file = os.path.join(OUTPUT_DIR, "all_momentum_perpetual.csv")
        all_results.to_csv(all_file, index=False)
        print(f"[OK] All momentum data saved to: {all_file}")
        
        # Save combined top and bottom
        combined = pd.concat([top_10, bottom_10], ignore_index=True)
        combined_file = os.path.join(OUTPUT_DIR, "momentum_perpetual_analysis.csv")
        combined.to_csv(combined_file, index=False)
        print(f"[OK] Combined analysis saved to: {combined_file}")
        
        return top_file, bottom_file
    
    def display_summary(self, top_10, bottom_10):
        """
        Displays a summary of the results.
        """
        print("\n" + "="*60)
        print("PERPETUAL FUTURES MOMENTUM ANALYSIS SUMMARY")
        print("="*60)
        
        print("\nTOP 10 MOMENTUM (Best 12-1 Month Performance):")
        print("-" * 60)
        for idx, row in top_10.iterrows():
            print(f"{row['rank']:2d}. {row['symbol']:8s} ({row['contract']:12s}) | "
                  f"Momentum: {row['momentum_12_1']:7.2%} | "
                  f"Current: ${row['current_price']:,.2f}")
        
        print("\nBOTTOM 10 MOMENTUM (Worst 12-1 Month Performance):")
        print("-" * 60)
        for idx, row in bottom_10.iterrows():
            print(f"{row['rank']:2d}. {row['symbol']:8s} ({row['contract']:12s}) | "
                  f"Momentum: {row['momentum_12_1']:7.2%} | "
                  f"Current: ${row['current_price']:,.2f}")
        
        print("\n" + "="*60)
        print("TRADING STRATEGY RECOMMENDATION:")
        print("-" * 60)
        print("- LONG: Consider buying top momentum perpetual contracts")
        print("- SHORT: Consider shorting bottom momentum contracts")
        print("- This analysis uses 12-1 month momentum strategy")
        print("- Based on Bybit perpetual futures data")
        print("="*60)

def main():
    """
    Main function to run the momentum analysis.
    """
    print("="*60)
    print("BYBIT PERPETUAL FUTURES MOMENTUM ANALYZER")
    print("Strategy: 12-1 Month Momentum")
    print("="*60)
    
    # Initialize analyzer
    analyzer = MomentumAnalyzer()
    
    # Read coin list from list.py output
    coin_df = analyzer.read_coin_list()
    
    if coin_df is not None:
        # Analyze momentum
        result = analyzer.analyze_coins(coin_df)
        
        if result[0] is not None and result[1] is not None:
            top_10, bottom_10, all_results = result
            
            # Save results
            analyzer.save_results(top_10, bottom_10, all_results)
            
            # Display summary
            analyzer.display_summary(top_10, bottom_10)
        else:
            print("\n[X] Failed to analyze momentum. No contracts with sufficient historical data.")
    else:
        print("\n[X] Failed to read coin list. Please run list.py first.")

if __name__ == "__main__":
    main()
